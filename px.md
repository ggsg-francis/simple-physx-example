This is a modification of the first few sections of the [PhysX official user manual](https://gameworksdocs.nvidia.com/PhysX/4.0/documentation/PhysXGuide/Index.html)
in an attempt at making an easier introduction for a first-time user.  
This page also draws from the version 3 archive on
[documentation.help](https://documentation.help/NVIDIA-PhysX-SDK-Guide/index.html),
as the sections on Scenes, Materials and Actors appear to be entirely missing from the current
documentation.

* [Using pandoc.css by killercup](https://gist.github.com/killercup/5917178)
* [Markdown source of this page](px.md)
* [HTML generated by Pandoc](https://pandoc.org)

Some bits are edited more than others. I'm lazy. I'm not an amazing
programmer so I might make mistakes. As it is, I think this page at
least makes for a better introduction than the real manual does.

I can be reached on Discord as `USER-PC#9045`  
Or by email: `benny_6566756 (at) hotmail.com`

This documentation is current as of PhysX 4.1

# A collapsible section with markdown
<details>
<summary>Click to expand!</summary>
life has many doors ed boy
</details>

## Index {#index}

* [Building PhysX](#building-physx)
* [Using PhysX](#using-physx)
* [Startup And Shutdown](#startup-and-shutdown)
* [Scene](#scene)  
* [Materials and Actors](#mat-act)
* [The Simulation Loop](#the-simulation-loop)
* [Sample Program](#sample-program)
* [End](#end)

___

## Building PhysX {#building-physx}

### Prerequisites

To build PhysX from source you need:

* [CMake](https://cmake.org/)
* [Python](https://www.python.org/downloads/)

### Generating projects with CMake

PhysX uses CMake to generate build configuration files (e.g. Microsoft Visual Studio Solutions) for all supported platforms. The PhysX distribution comes with default CMake parameter sets called presets. The build configuration files can be generated with the script generate_projects in the distributions "physx/" directory. This script either prompts for a preset or accepts a preset as a command line parameter.

The resulting build configuration files are generated under "physx/compiler/".

PhysX binaries (including static libraries) are placed into "bin/<platform>.<target>.<compiler>.<runtime>/<configuration>/" directories, for example the vc14win64 checked build puts binaries into "bin/win.x86_32.vc140.mt/checked/".

### Customizing CMake presets

It is possible to customize the CMake presets, which are stored in  
`"physx/buildtools/presets/public/"`

Each XML file represents one preset, depending on the platform some CMake switches can be toggled.

General switches:

* PX_BUILDSNIPPETS - specify whether the PhysX Snippets (Examples) should be added to the build configuration - default True

Windows switches:

* PX_GENERATE_STATIC_LIBRARIES - make PhysX build static libs instead of DLLs - default False
* NV_USE_STATIC_WINCRT - sets static or dynamic runtime usage - default True
* NV_USE_DEBUG_WINCRT - specify whether debug CRT should be used - default True
* PX_FLOAT_POINT_PRECISE_MATH - it is possible to switch to precise math rather than fast math, this is beneficial especially for robotics projects, which do require higher precision - default False

Some switches like PX_GENERATE_STATIC_LIBRARIES may result in a need for additional defines to be set within your application.
In this case you can include in your application PxConfig.h header, which is generated during generate projects.

~~~cpp
#include "PxConfig.h"
~~~

> If you're using Visual Studio 2015 like I am, then you may run into a
> CRT conflict when trying to link PhysXExtensions.
> 
> Here's my (bad) advice: Set PX_GENERATE_STATIC_LIBRARIES to True, causing
> all of the PhysX libraries to be statically linked, then make sure
> NV_USE_STATIC_WINCRT is set to the same as your program.
> This lets me link the extensions library for some reason.

### Build Configurations

The SDK has four build configurations available, designed for different stages of development and deployment.

* the debug build can be useful for error analysis, but contains asserts used for SDK development which some customers may find too intrusive for daily use. Optimizations are turned off for this configuration.
* the checked build contains code to detect invalid parameters, API race conditions, and other incorrect uses of the API which might otherwise cause mysterious crashes or failures in simulation.
* the profile build omits the checks, but still has PVD and memory instrumentation.
* the release build is built for minimal footprint and maximum speed. It omits most checks and instrumentation.

PhysX recommends that you use the checked mode for use in active development.

PhysX libraries built using differing configurations
(e.g. the DEBUG version of PhysXVehicle and the CHECKED version of PhysXVisualDebuggerSDK)
cannot be linked at the same time because this will result a CRT conflict.

## Using PhysX {#using-physx}

### Headers and Libraries

To build your own PhysX app, you will need to add some include paths and libraries to your project makefile or IDE.

Users should specify the root "include/" and corresponding "bin/" folders in the additional include, and library directories of their build configuration respectively. There is a combined include header available as:

```cpp
#include "PxPhysicsAPI.h"
```

This will include the entire PhysX API including core, extensions, vehicles, etc. It is also possible to include subsets of the SDK if preferred, for example:

```cpp
#include "vehicle/PxVehicleSDK.h"
```

As for the libraries, here's what my link list looks like:

* PhysX_*.lib
* PhysXCommon_*.lib
* PhysXFoundation_*.lib
* PhysXExtensions_*.lib
* PhysXCooking_*.lib
* PhysXPvdSDK_*.lib

Where * is a platform specific suffix, e.g. 32 or 64. You will need one or the other depending on whether your application is built in 64 bit mode.

> A lot of examples in the user manual reference functions and classes with
> names like 'PxDefaultSuchAndSuch' - These are a part of the PhysXExtensions
> library, but it's more than that. For example, the function PxCreateDynamic
> is defined in the PhysXExtensions library, and I don't even know how to create
> a dynamic actor without using that function. This library is considered
> optional, but it's necessary to link it to use the code written in the guide.

### DLLs

On the Windows platform, unless you've built PhysX as static libraries
you need to include some DLLs in your application's working directory.
These files can be found in "phys/bin/..." after building.

* PhysXCommon_*.dll - will always be needed.
* PhysX_*.dll - will always be needed.
* PhysXFoundation_*.dll - will always be needed.
* PhysXCooking_*.dll - you only need to bundle if your application cooks geometry data on the fly.
* PhysXGPU_*.dll - is only needed if your application runs some simulation on the GPU.

Where * is a platform specific suffix, e.g. 32 or 64. You will need one or the other depending on whether your application is built in 64 bit mode.

___


## Startup and Shutdown {#startup-and-shutdown}

### Introduction

The first step in using the PhysX SDK in a program is the initialization of some global objects. These objects can be released when PhysX is no longer needed to free resources. This chapter describes how to do this.

### Foundation and Physics

First, in some startup code, create a PxFoundation object:

~~~cpp
static PxDefaultErrorCallback gDefaultErrorCallback;
static PxDefaultAllocator gDefaultAllocatorCallback;

mFoundation = PxCreateFoundation(PX_PHYSICS_VERSION, gDefaultAllocatorCallback,
    gDefaultErrorCallback);
if(!mFoundation)
    fatalError("PxCreateFoundation failed!");
~~~

Every PhysX module requires a PxFoundation instance to be available. The required parameters are a version ID, an allocator callback and an error callback. PX_PHYSICS_VERSION, is a macro predefined in our headers to enable PhysX to check for a version mismatch between the headers and the corresponding SDK DLLs.

Usually, the allocator callback and error callback are specific to the application, but PhysX provides default implementations that make it easy to get started. See Memory Management and Error Reporting for more details of these callbacks. (The actual sample code supports an advanced memory allocator that tracks allocations instead of the default, but we have omitted that detail here.)

Now create the top-level PxPhysics object:

~~~cpp
bool recordMemoryAllocations = true;

mPhysics = PxCreatePhysics(PX_PHYSICS_VERSION, *mFoundation,
    PxTolerancesScale(), recordMemoryAllocations, nullptr);
if(!mPhysics)
    fatalError("PxCreatePhysics failed!");
~~~

Again, the version ID has to be passed in. The PxTolerancesScale parameter makes it easier to author content at different scales and still have PhysX work as expected, but to get started simply pass a default object of this type. The recordMemoryAllocations parameter specifies whether to perform memory profiling. The optional PVD instance enables the debugging and profiling with the PhysX Visual Debugger (I've changed it to nullptr, the PVD is not sufficiently explained, but it sure isn't needed).

### Cooking

The PhysX cooking library provides utilities for creating, converting, and serializing bulk data. Depending on your application, you may wish to link to the cooking library in order to process such data at runtime. Alternatively you may be able to process all such data in advance and just load it into memory as required. Initialize the cooking library as follows:

~~~cpp
mCooking = PxCreateCooking(PX_PHYSICS_VERSION, *mFoundation, PxCookingParams(scale));
if (!mCooking)
    fatalError("PxCreateCooking failed!");
~~~

The PxCookingParams struct configures the cooking library to target different platforms, use non-default tolerances or produce optional outputs. It is important to use consistent PxTolerancesScale values everywhere in your application (see Using Different Units for more details).

The cooking library generates data through a streaming interface. In the samples, implementations of streams are provided in the PxToolkit library to read and write from files and memory buffers. Heightfield or Trianglemesh cooked meshes can be directly inserted into PxPhysics without serialization using the PxPhysicsInsertionCallback. The default callback must be used and can be obtained using the PxPhysics::getPhysicsInsertionCallback().

### Extensions

The extensions library contains many functions that may be useful to a large class of users, but which some users may prefer to omit from their application either for code size reasons or to avoid use of certain subsystems, such as those pertaining to networking. Initializing the extensions library requires the PxPhysics object:

~~~cpp
if (!PxInitExtensions(*mPhysics, mPvd))
    fatalError("PxInitExtensions failed!");
~~~

If you don't have a PVD instance, you can pass nullptr.

~~~cpp
PxInitExtensions(*mPhysics, nullptr)
~~~

### Snip

In the original manual there's a section here about advanced initialization, delay-loading DLLs and such, but I cut it for the sake of the tutorial.
[Here's a link to that section if you want to read it anyway.](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/Startup.html#optional-sdk-components)

### Shutting Down

To dispose of any PhysX object, call its release() method. This will destroy the object, and all contained objects. The precise behavior depends on the object type being released, so refer to the reference guide for details. To shut down the extensions library, call the function PxCloseExtensions(). To shut down physics, call release() on the PxPhysics object, and this will clean up all of the physics objects:

~~~cpp
mPhysics->release();
~~~

Do not forget to release the foundation object as well, but only after all other PhysX modules have been released:

~~~cpp
mFoundation->release();
~~~

___

## Scene {#scene}

The PxScene object is the representation of the world in PhysX.
Creating the scene requires a number of immutable parameters to be specified in the
PxSceneDesc struct. 

A lot of PhysX objects have an IsValid() function, which checks whether the object has
been fully initialized. Which objects have this function? I don't know!! Let's find out together!!!!

The scene description contstructor `PxSceneDesc()` doesn't actually sufficiently fill out
the description, at least not in my experience, and `isValid()` will return false.
To alleviate this, I set the filterShader and cpuDispatcher properties, as seen in the
code below. These functions will require linking the `PhysXExtensions_*.lib` library.

~~~cpp
// Create a CPU dispatcher object with one thread
PxDefaultCpuDispatcher* disp = PxDefaultCpuDispatcherCreate(1u);

// Create the scene description and fill out its properties
// (scale is a PxTolerancesScale)
PxSceneDesc sceneDesc(scale);
sceneDesc.filterShader = PxDefaultSimulationFilterShader;
sceneDesc.cpuDispatcher = disp;
sceneDesc.gravity = PxVec3(0.f, -0.1f, 0.f);

// Check to ensure the scene description is valid
assert(sceneDesc.isValid());

// Create the scene
mScene = mPhysics->createScene(sceneDesc);

// Check to ensure the scene was created
assert(mScene);
~~~

The scene can be released in the same manner as the PxPhysics and PxFoundation classes.

~~~cpp
mScene->release();
~~~

___

## Materials and Actors {#mat-act}

### Materials

All physical objects have at least one material, which defines the friction and restitution properties used to resolve a collision with the objects. To create a material, call PxPhysics::createMaterial():

~~~cpp
PxMaterial* mMaterial;

mMaterial = mPhysics->createMaterial(0.5f, 0.5f, 0.1f);    //static friction, dynamic friction, restitution
if(!mMaterial)
    fatalError("createMaterial failed!");
~~~

Materials are owned by the PxPhysics object, and can be shared among objects in multiple scenes. The material properties of two objects involved in a collision may be combined in various ways. See the reference documentation for PxMaterial for more details.

PhysX objects whose collision geometry is a triangle mesh or a heightfield (see Shapes and Geometries) can have a material per triangle.

### Actors

Rigid actors are of two principal kinds: static and dynamic, corresponding to the PhysX classes PxRigidStatic and PxRigidDynamic. Static actors are immovable by the simulation, whereas dynamic actors have their positions updated by the simulation when simulate() is called. Dynamic actors may be controlled either directly by the application updating their position on a frame-by-frame basis (such actors are called kinematic), or by the simulation engine according to Newton's Laws of Motion.

### This section is a work in progress, sorry for the mistakes!

#### Adding a dynamic sphere

~~~cpp
PxRigidDynamic* actor = PxCreateDynamic(
	*mPhysics, // Handle to a PxPhysics instance
	PxTransform(PxVec3(0.f, 0.f, 0.f)), // Initial transform
	PxSphereGeometry(0.5f), // In this case I've used a sphere,
		// but you can use any PxGeometry inheritor
	*mMaterial, // Reference to the material created above
	1.f, // Density
	PxTransform(PxIdentity)); // Neutral shape offset
	
// Add this actor to the scene
mScene->addActor(*actor);
~~~

#### Adding a static triangle mesh

~~~cpp
PxTriangleMeshDesc meshDesc;
meshDesc.points.count = vces_size;
meshDesc.points.stride = sizeof(PxVec3);
meshDesc.points.data = vces;
// In my case the number of indices was the flat number of ints
// But physx expects the number of triangles, so I divide by 3
meshDesc.triangles.count = ices_size / 3u;
meshDesc.triangles.stride = 3u * sizeof(PxU32);
meshDesc.triangles.data = ices;

// live cooking
PxTriangleMesh* aTriangleMesh =
	mCooking->createTriangleMesh(meshDesc,
	mPhysics->getPhysicsInsertionCallback());

// Create geometry class
PxTriangleMeshGeometry geom(aTriangleMesh);
	assert(geom.isValid());

// Create an actor
PxRigidStatic* actorstatic = PxCreateStatic(
	*mPhysics, PxTransform(PxVec3(0.f, 0.f, 0.f)), geom, *mMaterial);
	
// Add the actor
mScene->addActor(*actorstatic);
~~~

### Examples

For example, to throw a simulated sphere from a specific position with an initial speed, create a dynamic actor following the first three steps above:

~~~cpp
PxRigidDynamic* aSphereActor =
	mPhysics->createRigidDynamic(PxTransform(position));
PxShape* aSphereShape = aSphereActor->createShape(
	PxSphereGeometry(radius), aMaterial);
PxRigidBodyExt::updateMassAndInertia(*aSphereActor, sphereDensity);
~~~

or equivalently:

~~~cpp
PxRigidDynamic* aSphereActor = PxCreateDynamic(
	*mPhysics, PxTransform(position), PxSphereGeometry(radius),
	aMaterial, sphereDensity);
~~~

Then specify an initial linear velocity vector:

~~~cpp
aSphereActor->setLinearVelocity(velocity);
~~~

And add the actor to a scene:

~~~cpp
aScene->addActor(*aSphereActor);
~~~

To create a static ground plane and add it to the simulation (The vector3 parameter determines the normal of the plane):

~~~cpp
PxRigidStatic* plane = PxCreatePlane(*mPhysics,
	PxPlane(PxVec3(0,1,0), 0), aMaterial);
if (!plane)
    fatalError("create shape failed!");
mScene->addActor(*plane);
~~~

___

## The Simulation Loop {#the-simulation-loop}

Use the method PxScene::simulate() to advance the world forward in time. Here is simplified code from the samples' fixed stepper class:

~~~cpp
mAccumulator = 0.0f;
mStepSize = 1.0f / 60.0f;

virtual bool advance(PxReal dt)
{
    mAccumulator  += dt;
    if(mAccumulator < mStepSize)
        return false;

    mAccumulator -= mStepSize;

    mScene->simulate(mStepSize);
    return true;
}
~~~

This is called from the sample framework whenever the app is done with processing events and is starting to idle. It accumulates elapsed real time until it is greater than a sixtieth of a second, and then calls simulate(), which moves all objects in the scene forward by that interval. This is probably the simplest of very many different ways to deal with time when stepping the simulation forward.

To allow the simulation to finish and return the results, simply call:

~~~cpp
mScene->fetchResults(true);
~~~

True indicates that the simulation should block until it is finished, so that on return the results are guaranteed to be available. When fetchResults completes, any simulation event callback functions that you defined will also be called. See the chapter Callback Sequence.

It is possible to read and write from the scene during simulation. The samples take advantage of this to perform rendering work in parallel with physics. Until fetchResults() returns, the results of the current simulation step are not available. So running rendering in parallel with simulation renders the actors as they were when simulate() was called. After fetchResults() returns, all these functions will return the new, post-simulate state. See the chapter Threading for more details about reading and writing while the simulation is running.

PhysX strongly recommends using a fixed timestep, upwards of 20 steps per second, for the sake of simulation stability.

___

## Sample Program {#sample-program}

If you find the PhysX sample programs a bit labyrinthian, yeah so do I.
Here's a basic sample program I made, which should compile as a single CPP file.

All it does is run a simple scene for 512 ticks, use the PhysX Visual Debugger program to see the results.
It links the libraries as follows,

* PhysX_static_64.lib
* PhysXCommon_static_64.lib
* PhysXFoundation_static_64.lib
* PhysXCooking_static_64.lib
* PhysXExtensions_static_64.lib
* PhysXPvdSDK_static_64.lib

~~~cpp
#include <assert.h>

#include "PxConfig.h"
#include "PxPhysicsAPI.h"

#define FRAME_TIME (1. / 30.)

using namespace physx;

PxFoundation* mFoundation = nullptr;
PxPhysics* mPhysics = nullptr;
PxCooking* mCooking = nullptr;
PxScene* mScene = nullptr;
PxMaterial* mMaterial = nullptr;
PxDefaultCpuDispatcher* disp;

PxPvd* pvd;
PxPvdTransport* transport;

PxDefaultAllocator allocator;
PxDefaultErrorCallback errorOut;

void PhysicsInit() {
	// Initialize foundation
	mFoundation = PxCreateFoundation(PX_PHYSICS_VERSION,
		allocator, errorOut);
	assert(mFoundation);

	pvd = PxCreatePvd(*mFoundation);
	assert(pvd);
	transport = PxDefaultPvdSocketTransportCreate("localhost", 5425, 10);
	assert(transport);
	pvd->connect(*transport, PxPvdInstrumentationFlag::eALL);

	// Set up the tolerance scale
	PxTolerancesScale scale;
	scale.length = 1.f;
	scale.speed = 2.f / FRAME_TIME;
	assert(scale.isValid());

	// Initialize physics
	bool recordMemoryAllocations = true;
	mPhysics = PxCreatePhysics(PX_PHYSICS_VERSION, *mFoundation,
		scale, recordMemoryAllocations, pvd);
	assert(mPhysics);

	// Initialize cooking
	mCooking = PxCreateCooking(PX_PHYSICS_VERSION,
		*mFoundation, PxCookingParams(scale));
	assert(mCooking);

	assert(PxInitExtensions(*mPhysics, pvd));

	// Make scene
	disp = PxDefaultCpuDispatcherCreate(1u);
	assert(disp);
	PxSceneDesc sceneDesc(scale);
	sceneDesc.filterShader = PxDefaultSimulationFilterShader;
	sceneDesc.cpuDispatcher = disp;
	sceneDesc.gravity = PxVec3(0.f, -0.4f, 0.f);
	assert(sceneDesc.isValid());
	mScene = mPhysics->createScene(sceneDesc);
	assert(mScene);

}

void PhysicsEnd() {
	mScene->release();
	disp->release();
	PxCloseExtensions();
	mCooking->release();
	mPhysics->release();
	pvd->release();
	transport->release();
	mFoundation->release();
}

void PhysicsTick(float dt) {
	mScene->simulate(dt);
	mScene->fetchResults(true);
}

void PhysicsCreateActors()
{
	// -------------------------------- Define the triangle mesh

	const PxU32 vces_size = 8;
	const PxVec3 vces[]{
		PxVec3(-1.f, 0.f, -1.f),
		PxVec3(-1.f, 0.f, 1.f),
		PxVec3(1.f, 0.f, -1.f),
		PxVec3(1.f, 0.f, 1.f),

		PxVec3(-2.f, 0.5f, -2.f),
		PxVec3(-2.f, 0.5f, 2.f),
		PxVec3(2.f, 0.5f, -2.f),
		PxVec3(2.f, 0.5f, 2.f)
	};
	const PxU32 ices_size = 30;
	const PxU32 ices[]{ 
		0u, 1u, 3u,
		0u, 3u, 2u,

		4u, 5u, 1u,
		4u, 1u, 0u,

		1u, 5u, 7u,
		1u, 7u, 3u,

		2u, 3u, 7u,
		2u, 7u, 6u,

		4u, 0u, 2u,
		4u, 2u, 6u
	};

	// -------------------------------- Create a material

	mMaterial = mPhysics->createMaterial(0.5f, 0.5f, 0.1f);

	// -------------------------------- Create a rigidbody

	PxRigidDynamic* rigidactor_ball = PxCreateDynamic(*mPhysics,
		PxTransform(PxVec3(1.5f, 3.f, 1.5f)),
		PxSphereGeometry(0.5f), *mMaterial, 0.2f,
		PxTransform(PxIdentity));

	rigidactor_ball->setLinearVelocity(PxVec3(0.f, -4.f, 0.f));

	// -------------------------------- Create a triangle mesh

	PxTriangleMeshDesc meshDesc;
	meshDesc.points.count = vces_size;
	meshDesc.points.stride = sizeof(PxVec3);
	meshDesc.points.data = (void*)vces;
	meshDesc.triangles.count = ices_size / 3u;
	meshDesc.triangles.stride = 3u * sizeof(PxU32);
	meshDesc.triangles.data = (void*)ices;

	assert(meshDesc.isValid());

	//* live cooking
	PxTriangleMesh* aTriangleMesh = mCooking->createTriangleMesh(meshDesc,
		mPhysics->getPhysicsInsertionCallback());
	assert(aTriangleMesh);
	//*/

	/* How to make a cooked mesh for saving to a file or something
	PxDefaultMemoryOutputStream writeBuffer;
	PxTriangleMeshCookingResult::Enum result;
	bool status = mCooking->cookTriangleMesh(meshDesc, writeBuffer, &result);
	assert(status);
	PxDefaultMemoryInputData readBuffer(writeBuffer.getData(), writeBuffer.getSize());
	PxTriangleMesh* aTriangleMesh = mPhysics->createTriangleMesh(readBuffer);
	//*/

	//* A simple method of creating the triangle mesh
	PxTriangleMeshGeometry geom(aTriangleMesh);
	assert(geom.isValid());
	PxRigidStatic* rigidactor_world = PxCreateStatic(*mPhysics, PxTransform(PxVec3(0.f, 0.f, 0.f)), geom, *mMaterial);
	assert(rigidactor_world);
	//*/

	/* An alternative method of creating the triangle mesh
	PxShape* shape_world =
	mPhysics->createShape(PxTriangleMeshGeometry(aTriangleMesh), *mMaterial, true);
	assert(shape_world);
	PxRigidStatic* rigidactor_world =
	mPhysics->createRigidStatic(PxTransform(PxVec3(0.f, 0.f, 0.f)));
	assert(rigidactor_world);
	rigidactor_world->attachShape(*shape_world);
	//*/

	// -------------------------------- Add the actors to the scene

	mScene->addActor(*rigidactor_ball);
	mScene->addActor(*rigidactor_world);
}

int main(char* argc, char** argv)
{
	PhysicsInit();
	PhysicsCreateActors();

	for (int i = 0; i < 512; ++i)
		PhysicsTick(FRAME_TIME);

	PhysicsEnd();

	return 0;
}
~~~

___

## End {#end}

That's all there is for this tutorial, at least for now. The official manual continues [from here](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/Threading.html),
although I would recommend skipping the multithreading part for now and continuing from the [geometry](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/Geometry.html)
section.

___